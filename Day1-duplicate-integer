Q1- https://neetcode.io/problems/duplicate-integer?list=neetcode150

Solution-

Using Sorting-

C++ solution- 

class Solution {
public:
    bool hasDuplicate(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] == nums[i - 1]) {
                return true;
            }
        }
        return false;
    }
};

Python Solution-

class Solution:
    def hasDuplicate(self, nums: List[int]) -> bool:
        nums.sort()
        for i in range(1, len(nums)):
            if nums[i] == nums[i - 1]:
                return True
        return False

Kotlin Solution-

class Solution {
    fun hasDuplicate(nums: IntArray): Boolean {
        nums.sort()
        for (i in 1 until nums.size) {
            if (nums[i] == nums[i - 1]) {
                return true
            }
        }
        return false
    }
}



Time & Space Complexity
Time complexity: O(nlogn)
Space complexity: O(1) or O(n) depending on the sorting algorithm.

Hash Set-

C++ solution- 

class Solution {
public:
    bool hasDuplicate(vector<int>& nums) {
        unordered_set<int> seen;
        for (int num : nums) {
            if (seen.count(num)) {
                return true;
            }
            seen.insert(num);
        }
        return false;
    }
};

Python solution-

class Solution:
    def hasDuplicate(self, nums: List[int]) -> bool:
        seen = set()
        for num in nums:
            if num in seen:
                return True
            seen.add(num)
        return False


Kotlin solution-

class Solution {
    fun hasDuplicate(nums: IntArray): Boolean {
        val seen = HashSet<Int>()
        for (num in nums) {
            if (num in seen) {
                return true
            }
            seen.add(num)
        }
        return false
    }
}


Time & Space Complexity
Time complexity: O(n)
Space complexity: O(n)


Hash Set Length

C++ solution- 

class Solution {
public:
    bool hasDuplicate(vector<int>& nums) {
        return unordered_set<int>(nums.begin(), nums.end()).size() < nums.size();
    }
};

Python Solution:

class Solution:
    def hasDuplicate(self, nums: List[int]) -> bool:
        return len(set(nums)) < len(nums)

Kotlin-

class Solution {
    fun hasDuplicate(nums: IntArray): Boolean {
        return nums.toSet().size < nums.size
    }
}

==============================================================================================================================================================================

Mine idiotic solution in C++ using Map-

#include <unordered_map>

class Solution {
public:
    bool hasDuplicate(vector<int>& nums) {

        std::unordered_map<int, int> count_freq;
        for(int a : nums)
        {
         if(count_freq.count(a)>0)
            //count_freq[a]+=1;
            return true;
          else
            count_freq[a]=1;

        }

       /* for (const auto& pair : count_freq) {
         if(pair.second>1)
             return true;
    }*/
      return false;  
    }
};

