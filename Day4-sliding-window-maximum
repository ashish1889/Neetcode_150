Q- https://neetcode.io/problems/sliding-window-maximum/question


1. Brute Force-

C++ solution-

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> output;
        int n = nums.size();

        for (int i = 0; i <= n - k; i++) {
            int maxi = nums[i];
            for (int j = i; j < i + k; j++) {
                maxi = max(maxi, nums[j]);
            }
            output.push_back(maxi);
        }

        return output;
    }
};

Python solution-
Kotlin solution-

Time & Space Complexity
Time complexity:O(n*k)
Space complexity:O(1) extra space , O(n-k+1) space for the output array.
Where n is the length of the array and k is the size of the window.


2. Segment Tree- Need to understand concept
C++ solution-

class SegmentTree {
public:
    int n;
    vector<int> tree;

    SegmentTree(int N, vector<int>& A) {
        this->n = N;
        while (__builtin_popcount(n) != 1) {
            n++;
        }
        build(N, A);
    }

    void build(int N, vector<int>& A) {
        tree.resize(2 * n, INT_MIN);
        for (int i = 0; i < N; i++) {
            tree[n + i] = A[i];
        }
        for (int i = n - 1; i > 0; --i) {
            tree[i] = max(tree[i << 1], tree[i << 1 | 1]);
        }
    }

    int query(int l, int r) {
        int res = INT_MIN;
        for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {
            if (l & 1) res = max(res, tree[l++]);
            if (r & 1) res = max(res, tree[--r]);
        }
        return res;
    }
};

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        SegmentTree segTree(n, nums);
        vector<int> output;
        for (int i = 0; i <= n - k; i++) {
            output.push_back(segTree.query(i, i + k - 1));
        }
        return output;
    }
};


Python solution-
Kotlin solution-

Time & Space Complexity
Time complexity:O(nlogn)
Space complexity:O(n)


3. Heap-

C++ solution-

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        priority_queue<pair<int, int>> heap;
        vector<int> output;
        for (int i = 0; i < nums.size(); i++) {
            heap.push({nums[i], i});
            if (i >= k - 1) {
                while (heap.top().second <= i - k) {
                    heap.pop();
                }
                output.push_back(heap.top().first);
            }
        }
        return output;
    }
};

Python solution-
Kotlin solution-

Time & Space Complexity
Time complexity:O(nlogn)
Space complexity:O(n)


4. Dynamic Programming-

C++ solution-

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> leftMax(n);
        vector<int> rightMax(n);

        leftMax[0] = nums[0];
        rightMax[n - 1] = nums[n - 1];

        for (int i = 1; i < n; i++) {
            if (i % k == 0) { //Condition where window is changed- Dry run below
                leftMax[i] = nums[i];
            } else {
                leftMax[i] = max(leftMax[i - 1], nums[i]);
            }

            if ((n - 1 - i) % k == 0) { //Condition where window is changed- Dry run below
                rightMax[n - 1 - i] = nums[n - 1 - i];
            } else {
                rightMax[n - 1 - i] = max(rightMax[n - i], nums[n - 1 - i]);
            }
        }

        vector<int> output(n - k + 1);

        for (int i = 0; i < n - k + 1; i++) {
            output[i] = max(leftMax[i + k - 1], rightMax[i]);
        }

        return output;
    }
};

Python solution-
Kotlin solution-

Time & Space Complexity
Time complexity:O(n)
Space complexity:O(n)

In DP for understanding of code snippet-

leftMax[0] = nums[0];
        rightMax[n - 1] = nums[n - 1];
 
        for (int i = 1; i < n; i++) {
            if (i % k == 0) {
                leftMax[i] = nums[i];
            } else {
                leftMax[i] = max(leftMax[i - 1], nums[i]);
            }
 
            if ((n - 1 - i) % k == 0) {
                rightMax[n - 1 - i] = nums[n - 1 - i];
            } else {
                rightMax[n - 1 - i] = max(rightMax[n - i], nums[n - 1 - i]);
            }
        }
 
nums=[1,2,1,0,4,2,6]
k=3
Left max array: [1,2,2,0,4,4,6,]
Right max array: [1,2,1,0,6,6,6,]
7-3+1 = 5
 
vector<int> output(n - k + 1);
 
        for (int i = 0; i < n - k + 1; i++) {
            output[i] = max(leftMax[i + k - 1], rightMax[i]);
        }



5. Deque-

C++ solution-

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> output(n - k + 1);
        deque<int> q;
        int l = 0, r = 0;

        while (r < n) {
            while (!q.empty() && nums[q.back()] < nums[r]) {
                q.pop_back();
            }
            q.push_back(r);

            if (l > q.front()) { // Condition if sliding window moved ahead
                q.pop_front();
            }

            if ((r + 1) >= k) { // Sliding window boundary condition
                output[l] = nums[q.front()];
                l++;
            }
            r++;
        }

        return output;
    }
};

Python solution-
Kotlin solution-

Time & Space Complexity
Time complexity:O(n)
Space complexity:O(n)
