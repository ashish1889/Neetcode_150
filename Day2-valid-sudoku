Q- https://neetcode.io/problems/valid-sudoku?list=neetcode150


1. BruteForce-

C++ solution-

class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        for (int row = 0; row < 9; row++) {
            unordered_set<char> seen;
            for (int i = 0; i < 9; i++) {
                if (board[row][i] == '.') continue;
                if (seen.count(board[row][i])) return false;
                seen.insert(board[row][i]);
            }
        }

        for (int col = 0; col < 9; col++) {
            unordered_set<char> seen;
            for (int i = 0; i < 9; i++) {
                if (board[i][col] == '.') continue;
                if (seen.count(board[i][col])) return false;
                seen.insert(board[i][col]);
            }
        }

        for (int square = 0; square < 9; square++) {
            unordered_set<char> seen;
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    int row = (square / 3) * 3 + i;
                    int col = (square % 3) * 3 + j;
                    if (board[row][col] == '.') continue;
                    if (seen.count(board[row][col])) return false;
                    seen.insert(board[row][col]);
                }
            }
        }

        return true;
    }
};

Python solution-
Kotlin solution-

Time & Space Complexity
Time complexity: O(n^2)
Space complexity: O(n)


2. Hash Set (One Pass)-

C++ solution-

class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        unordered_map<int, unordered_set<char>> rows, cols;
        map<pair<int, int>, unordered_set<char>> squares;

        for (int r = 0; r < 9; r++) {
            for (int c = 0; c < 9; c++) {
                if (board[r][c] == '.') continue;

                pair<int, int> squareKey = {r / 3, c / 3};

                if (rows[r].count(board[r][c]) || cols[c].count(board[r][c]) || squares[squareKey].count(board[r][c])) {
                    return false;
                }

                rows[r].insert(board[r][c]);
                cols[c].insert(board[r][c]);
                squares[squareKey].insert(board[r][c]);
            }
        }
        return true;
    }
};

Python solution-
Kotlin solution-

Time & Space Complexity
Time complexity: O(n^2)
Space complexity: O(n^2)


3. Bitmask-

C++ solution-

class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int rows[9] = {0};
        int cols[9] = {0};
        int squares[9] = {0};

        for (int r = 0; r < 9; ++r) {
            for (int c = 0; c < 9; ++c) {
                if (board[r][c] == '.') continue;

                int val = board[r][c] - '1';

                if ((rows[r] & (1 << val)) || (cols[c] & (1 << val)) ||
                    (squares[(r / 3) * 3 + (c / 3)] & (1 << val))) {
                    return false;
                }

                rows[r] |= (1 << val);
                cols[c] |= (1 << val);
                squares[(r / 3) * 3 + (c / 3)] |= (1 << val);
            }
        }
        return true;
    }
};

Python solution-
Kotlin solution-

Understanding the 3x3 Sub-Boxes

Imagine the 9x9 Sudoku board divided into nine 3x3 sub-boxes. We need a way to uniquely identify each of these sub-boxes using a number from 0 to 8.

Row and Column Division

r / 3:  This performs integer division of the row number r by 3.  The result tells us which row of 3x3 sub-boxes the cell belongs to.

If r is 0, 1, or 2, r / 3 is 0 (top row of sub-boxes).
If r is 3, 4, or 5, r / 3 is 1 (middle row of sub-boxes).
If r is 6, 7, or 8, r / 3 is 2 (bottom row of sub-boxes).
c / 3: This performs integer division of the column number c by 3.  The result tells us which column of 3x3 sub-boxes the cell belongs to.

If c is 0, 1, or 2, c / 3 is 0 (leftmost column of sub-boxes).
If c is 3, 4, or 5, c / 3 is 1 (middle column of sub-boxes).
If c is 6, 7, or 8, c / 3 is 2 (rightmost column of sub-boxes).
Calculating the Index

Now, we combine these two results to get the index of the 3x3 sub-box:

(r / 3) * 3: This calculates the starting index for the row of 3x3 sub-boxes the cell is in. 
We multiply by 3 because there are 3 sub-boxes in each row of 3x3 sub-boxes.
+ (c / 3): This adds the column offset within that row of sub-boxes.
Example

Let's say we have a cell at r = 4, c = 5.

r / 3 = 4 / 3 = 1
c / 3 = 5 / 3 = 1
(r / 3) * 3 + (c / 3) = (1 * 3) + 1 = 3 + 1 = 4
So, the cell at r = 4, c = 5 belongs to the 3x3 sub-box with index 4.

Mapping to the squares Array

The squares array has 9 elements (indices 0 to 8), one for each 3x3 sub-box. Therefore, the formula (r / 3) * 3 + (c / 3) ensures 
that we always get a valid index within the range of the squares array.

In Summary

The formula effectively converts the 2D coordinates (row r and column c) of a cell into a 1D index representing the 3x3 sub-box it belongs to. 
This allows us to efficiently track the numbers that have already been used in each sub-box using the squares array.

Time & Space Complexity
Time complexity: O(n^2)
Space complexity: O(n)
